---
source: Rmd
title: "R for Plotting"
teaching: 90
exercises: 20
questions:
- "What are geometries and aesthetics?"
- "How can I use R to create and save professional data visualizations?"
objectives:
- "To create plots with both discrete and continuous variables."
- "To understand mapping and layering using `ggplot2`."
- "To be able to modify a plot's color, theme, and axis labels."
- "To be able to save plots to a local directory."
keypoints:
- "Geometries are the visual elements drawn on data visualizations (lines, points, etc.), and aesthetics are the visual properties of those geometries (color, position, etc.)."
- "Use `ggplot()` and geoms to create data visualizations, and save them using `ggsave()`."

---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("02-")
```

```{r echo=FALSE}
# prevents jitter plots from changing
set.seed(20210109)
```


### Contents

1. [Creating our first plot](#creating-our-first-plot)
1. [Plotting for data exploration](#plotting-for-data-exploration)
    + [Importing datasets](#importing-datasets)
    + [Discrete plots](#discrete-plots)
    + [Layers](#layers)
    + [Color vs. Fill](#color-vs-fill)
    + [Univariate plots](#univariate-plots)
    + [Plot themes](#plot-themes)
    + [Facets](#facets)
    + [Saving plots](#saving-plots)
1. [Applying it to your own data](#applying-it-to-your-own-data)
1. [Glossary of terms](#glossary-of-terms)

# Creating our first plot
_[Back to top](#contents)_

We will be using the `ggplot2` package today to make our plots. This is a very
powerful package that creates professional looking plots and is one of the
reasons people like using R so much. All plots made using the `ggplot2` package
start by calling the `ggplot()` function. So in the tab you created for the
`gdp_population.R` file, type the following:

```{r ggplotDataOnly}
ggplot(data=gapminder_1997)
```

To run code that you've typed in the editor, you have a few options. Remember
that the quickest way to run the code is by pressing
<kbd>Ctrl</kbd>+<kbd>Enter</kbd> on your keyboard. This will run the line of
code that currently contains your cursor or any highlighted code.

When we run this code, the **Plots** tab will pop to the front in the lower
right corner of the RStudio screen. Right now, we just see a big grey rectangle.

What we've done is created a ggplot object and told it we will be using the data
from the `gapminder_1997` object that we've loaded into R. We've done this by
calling the `ggplot()` function with `gapminder_1997` as the `data` argument.

So we've made a plot object, now we need to start telling it what we actually
want to draw in this plot. The elements of a plot have a bunch of properties
like an x and y position, a size, a color, etc. These properties are called
**aesthetics**. When creating a data visualization, we  map a variable in our
dataset to an aesthetic in our plot. In ggplot, we can do this by creating an
"aesthetic mapping", which we do with the `aes()` function.

To create our plot, we need to map variables from our `gapminder_1997` object to
ggplot aesthetics using the `aes()` function. Since we have already told
`ggplot` that we are using the data in the `gapminder_1997` object, we can
access the columns of `gapminder_1997` using the object's column names.
(Remember, R is case-sensitive, so we have to be careful to match the column
names exactly!)

We are interested in whether there is a relationship between GDP and life
expectancy, so let's start by telling our plot object that we want to map our
GDP values to the x axis of our plot. We do this by adding (`+`) information to
our plot object. Add this new line to your code and run both lines by
highlighting them and pressing <kbd>Ctrl</kbd>+<kbd>Enter</kbd> on your
keyboard:

```{r, ggplotX}
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap)
```

Note that we've added this new function call to a second line just to make it
easier to read. To do this we make sure that the `+` is at the end of the first
line otherwise R will assume your command ends when it starts the next row. The
`+` sign indicates not only that we are adding information, but to continue on
to the next line of code.

Observe that our **Plot** window is no longer a grey square. We now see that
we've mapped the `gdpPercap` column to the x axis of our plot. Note that that
column name isn't very pretty as an x-axis label, so let's add the `labs()`
function to make a nicer label for the x axis

```{r FirstPlotAddXLabel}
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap) +
  labs(x = "GDP Per Capita")
```

OK. That looks better. 

> ## Quotes vs No Quotes
> Notice that when we added the label value we did so by placing the values
> inside quotes. This is because we are not using a value from inside our data
> object - we are providing the name directly. When you need to include actual
> text values in R, they will be placed inside quotes to tell them apart from
> other object or variable names.
> 
> The general rule is that if you want to use values from the columns of your
> data object, then you supply the name of the column without quotes, but if you
> want to specify a value that does not come from your data, then use quotes.
{: .callout}

> ## Mapping life expectancy to the y axis
> Map our `lifeExp` values to the y axis and give them a nice label.
> {: .source}
>
>
> > ## Solution
> > ```{r FirstPlotAddY}
> > ggplot(data = gapminder_1997) +
> >   aes(x = gdpPercap) +
> >   labs(x = "GDP Per Capita") +
> >   aes(y = lifeExp) +
> >   labs(y = "Life Expectancy")
> > ```
> > {: .source}
> {: .solution}
{: .challenge}

Excellent. We've now told our plot object where the x and y values are coming
from and what they stand for. But we haven't told our object how we want it to
draw the data. There are many different plot types (bar charts, scatter plots,
histograms, etc). We tell our plot object what to draw by adding a "geometry"
("geom" for short) to our object. We will talk about many different geometries
today, but for our first plot, let's draw our data using the "points" geometry
for each value in the data set. To do this, we add `geom_point()` to our plot
object:

```{r FirstPlotAddPoints}
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap) +
  labs(x = "GDP Per Capita") +
  aes(y = lifeExp) +
  labs(y = "Life Expectancy") +
  geom_point()
```

Now we're really getting somewhere. It finally looks like a proper plot!  We can
now see a trend in the data. It looks like countries with a larger GDP tend to
have a higher life expectancy. Let's add a title to our plot to make that
clearer. Again, we will use the `labs()` function, but this time we will use the
`title =` argument.

```{r FirstPlotAddTitle}
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap) +
  labs(x = "GDP Per Capita") +
  aes(y = lifeExp) +
  labs(y = "Life Expectancy") +
  geom_point() +
  labs(title = "Do people in wealthy countries live longer?")
```

No one can deny we've made a very handsome plot! But now looking at the data, we
might be curious about learning more about the points that are the extremes of
the data. We know that we have two more pieces of data in the `gapminder_1997`
object that we haven't used yet. Maybe we are curious if the different
continents show different patterns in GDP and life expectancy. One thing we
could do is use a different color for each of the continents. To map the
continent of each point to a color, we will again use the `aes()` function:

```{r FirstPlotAddColor}
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap) +
  labs(x = "GDP Per Capita") +
  aes(y = lifeExp) +
  labs(y = "Life Expectancy") +
  geom_point() +
  labs(title = "Do people in wealthy countries live longer?") +
  aes(color = continent)
```

Here we can see that in 1997 the African countries had much lower life
expectancy than many other continents. Notice that when we add a mapping for
color, ggplot automatically provided a legend for us. It took care of assigning
different colors to each of our unique values of the `continent` variable. (Note
that when we mapped the x and y values, those drew the actual axis labels, so in
a way the axes are like the legends for the x and y values). The colors that
ggplot uses are determined by the color "scale". Each aesthetic value we can
supply (x, y, color, etc) has a corresponding scale. Let's change the colors to
make them a bit prettier.

```{r FirstPlotAddColorScale}
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap) +
  labs(x = "GDP Per Capita") +
  aes(y = lifeExp) +
  labs(y = "Life Expectancy") +
  geom_point() +
  labs(title = "Do people in wealthy countries live longer?") +
  aes(color = continent) +
  scale_color_brewer(palette = "Set1")
```

The `scale_color_brewer()` function is just one of many you can use to change
colors. There are bunch of "palettes" that are build in. You can view them all
by running `RColorBrewer::display.brewer.all()` or check out the [Color Brewer
website](https://colorbrewer2.org/) for more info about choosing plot colors.

There are also lots of other fun options:

- [Viridis](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html)
- [National parks](https://github.com/katiejolly/nationalparkcolors)
- [LaCroix](https://github.com/johannesbjork/LaCroixColoR)
- [Wes Anderson](https://github.com/karthik/wesanderson)

> ## Bonus Exercise: Changing colors
> Play around with different color palettes. Feel free to install another
> package and choose one of those if you want. Pick your favorite!
> {: .source}
>
> > ## Solution
> > You can use RColorBrewer::display.brewer.all() to pick a color palette. 
> > As a bonus, you can also use one of the packages listed above. 
> > Here's an example:
> > 
> > ```{r Color}
> > #install.packages("wesanderson") # install package from GitHub
> > library(wesanderson)
> > ggplot(data = gapminder_1997) +
> > aes(x = gdpPercap) +
> > labs(x = "GDP Per Capita") +
> > aes(y = lifeExp) +
> > labs(y = "Life Expectancy") +
> > geom_point() +
> > labs(title = "Do people in wealthy countries live longer?") +
> > aes(color = continent) +
> > scale_color_manual(values = wes_palette('Cavalcanti1'))
> > ```
> > {: .source}
> {: .solution}
{: .challenge}

Since we have the data for the population of each country, we might be curious
what effect population might have on life expectancy and GDP per capita. Do you
think larger countries will have a longer or shorter life expectancy? Let's find
out by mapping the population of each country to the size of our points.

```{r FirstPlotAddSize}
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap) +
  labs(x = "GDP Per Capita") +
  aes(y = lifeExp) +
  labs(y = "Life Expectancy") +
  geom_point() +
  labs(title = "Do people in wealthy countries live longer?") +
  aes(color = continent) +
  scale_color_brewer(palette = "Set1") +
  aes(size = pop)
```

There doesn't seem to be a very strong association with population size. We can
see two very large countries with relatively low GDP per capita (but since the
per capita value is already divided by the total population, there is some
problems with separating those two values). We got another legend here for size
which is nice, but the values look a bit ugly in scientific notation. Let's
divide all the values by 1,000,000 and label our legend "Population (in
millions)"

```{r FirstPlotAddPop}
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap) +
  labs(x = "GDP Per Capita") +
  aes(y = lifeExp) +
  labs(y = "Life Expectancy") +
  geom_point() +
  labs(title = "Do people in wealthy countries live longer?") +
  aes(color = continent) +
  scale_color_brewer(palette = "Set1") +
  aes(size = pop/1000000) +
  labs(size = "Population (in millions)")
```

This works because you can treat the columns in the aesthetic mappings just like
any other variables and can use functions to transform or change them at plot
time rather than having to transform your data first.

Good work! Take a moment to appreciate what a cool plot you made with a few
lines of code. In order to fully view its beauty you can click the "Zoom" button
in the **Plots** tab - it will break free from the lower right corner and open
the plot in its own window.

> ## Changing shapes
> Instead of (or in addition to) color, change the shape of the points so each continent has a different shape. (I'm not saying this is a great thing to do - it's just for practice!) HINT: Is size an aesthetic or a geometry? If you're stuck, feel free to Google it, or look at the help menu.
> {: .source}
>
> > ## Solution
> > You'll want to use the `aes` aesthetic function to change the shape:
> > ```{r Shape}
> > ggplot(data = gapminder_1997) +
> >   aes(x = gdpPercap) +
> >   labs(x = "GDP Per Capita") +
> >   aes(y = lifeExp) +
> >   labs(y = "Life Expectancy") +
> >   geom_point() +
> >   labs(title = "Do people in wealthy countries live longer?") +
> >   aes(color = continent) +
> >   scale_color_brewer(palette = "Set1") +
> >   aes(size = pop/1000000) +
> >   labs(size = "Population (in millions)") +
> >   aes(shape = continent)
> > ```
> > {: .source}
> {: .solution}
{: .challenge}

For our first plot we added each line of code one at a time so you could see the
exact affect it had on the output. But when you start to make a bunch of plots,
we can actually combine many of these steps so you don't have to type as much.
For example, you can collect all the `aes()` statements and all the `labs()`
together. A more condensed version of the exact same plot would look like this:

```{r FirstPlotCondensed}
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap, y = lifeExp, color = continent, size = pop/1000000) +
  geom_point() +
  scale_color_brewer(palette = "Set1") +
  labs(x = "GDP Per Capita", y = "Life Expectancy",
    title = "Do people in wealthy countries live longer?", size = "Population (in millions)")
```

# Plotting for data exploration
_[Back to top](#contents)_

Many datasets are much more complex than the example we used for the first plot.
How can we find meaningful patterns in complex data and create visualizations to
convey those patterns?

## Importing datasets
_[Back to top](#contents)_

In the first plot, we looked at a smaller slice of a large dataset. To gain a
better understanding of the kinds of patterns we might observe in our own data,
we will now use the full dataset, which is stored in a file called
"gapminder_data.csv".

To start, we will read in the data without using the interactive RStudio file navigation.

```{r ImportFullDataSolutionEval, echo = FALSE}
gapminder_data <- read_csv("data/gapminder_data.csv")
```

> ## Read in your own data
>
> What argument should be provided in the below code to read in the full dataset?
>
> ```{r ImportFullData, eval = FALSE}
> gapminder_data <- read_csv()
> ```
>
> > ## Solution
> >
> > ```{r ImportFullDataSolutionEcho, eval = FALSE}
> > gapminder_data <- read_csv("data/gapminder_data.csv")
> > ```
> {: .solution}
{: .challenge}

Let's take a look at the full dataset. We could use `View()`, the way we did for the smaller dataset, but if your data is too big, it might take too long to load. Luckily, R offers a way to look at parts of the data to get an idea of what your dataset looks like, without having to examine the whole thing. Here are some commands that allow us to get the dimensions of our data and look at a snapshot of the data. Try them out!

```{r InitialExploration, eval = FALSE}
dim(gapminder_data)
head(gapminder_data)
```

Notice that this dataset has an additional column `year` compared to the smaller dataset we started with.

> ## Predicting `ggplot` outputs
> Now that we have the full dataset read into our R session, let's plot the data placing our new `year` variable on the x axis and life expectancy on the y axis. We've provided the code below. Notice that we've collapsed the plotting function options and left off some of the labels so there's not as much code to work with.
> Before running the code, read through it and see if you can predict what the plot output will look like. Then run the code and check to see if you were right!
>
> ```{r PlotFullGapminder}
>  ggplot(data = gapminder_data) +
>  aes(x=year, y=lifeExp, color=continent) +
>  geom_point()
> ```
>
{: .challenge}

Hmm, the plot we created in the last exercise isn't very clear. What's going on? Since the dataset is more complex, the plotting options we used for the smaller dataset aren't as useful for interpreting these data. Luckily, we can add additional attributes to our plots that will make patterns more apparent. For example, we can generate a different type of plot - perhaps a line plot - and assign attributes for columns where we might expect to see patterns.

Let's review the columns and the types of data stored in our dataset to decide how we should group things together. To get an overview of our data object, we can look at the structure of `gapminder_data` using the `str()` function.

```{r DataExploration, eval=FALSE}
str(gapminder_data)
```

(You can also review the structure of your data in the **Environment** tab by clicking on the blue circle with the arrow in it next to your data object name.)

So, what do we see? The column names are listed after a `$` symbol, and then we have a `:` followed by a text label. These labels correspond to the type of data stored in each column.

What kind of data do we see?
* "int" = Integer (or whole number)
* "num" = Numeric (or non-whole number)
* "chr" = Character (categorical data)

**Note** In anything before R 4.0, categorical variables used to be read in as factors, which are a [special data object](https://www.tutorialspoint.com/r/r_factors.htm) that are used to store categorical data and have limited numbers of unique values. The unique values of a factor are tracked via the "levels" of a factor. A factor will always remember all of its levels even if the values don't actually appear in your data. The factor will also remember the order of the levels and will always print values out in the same order (by default this order is alphabetical).

If your columns are stored as character values but you need factors for plotting, ggplot will convert them to factors for you as needed.

Our plot has a lot of points in columns which makes it hard to see trends over time. A better way to view the data showing changes over time is to use a [line plot](http://www.sthda.com/english/wiki/ggplot2-line-plot-quick-start-guide-r-software-and-data-visualization). Let's try changing the geom to a line and see what happens.

```{r GapMinderLinePlotBad}
  ggplot(data = gapminder_data) +
  aes(x = year, y = lifeExp, color = continent) +
    geom_line()
```

Hmm. This doesn't look right. By setting the color value, we got a line for each continent, but we really wanted a line for each country. We need to tell ggplot that we want to connect the values for each `country` value instead. To do this, we need to use the `group=` aesthetic.

```{r GapMinderLinePlot}
  ggplot(data = gapminder_data) +
  aes(x = year, y = lifeExp, group = country, color = continent) +
    geom_line()
```

Sometimes plots like this are called "spaghetti plots" because all the lines look like a bunch of wet noodles.

> ## Bonus Exercise: More line plots
> Now create your own line plot comparing population and life expectancy! Looking at your plot, can you guess which two countries have experienced massive change in population from 1952-2007?
>
> > ## Solution
> > ```{r gapminderMoreLines}
> > ggplot(data = gapminder_data) +
> >  aes(x = pop, y = lifeExp, group = country, color = continent) +
> >  geom_line()
> > ```
> > (China and India are the two Asian countries that have experienced massive population growth from 1952-2007.)
> {: .solution}
{: .challenge}

## Discrete Plots
_[Back to top](#contents)_

So far we've looked at two plot types (`geom_point` and `geom_line`) which work when both the x and y values are numeric. But sometimes you may have one of your values be discrete (a factor or character).

We've previously used the discrete values of the `continent` column to color in our points and lines. But now let's try moving that variable to the `x` axis. Let's say we are curious about comparing the distribution of the life expectancy values for each of the different continents for the `gapminder_1997` data. We can do so using a box plot. Try this out yourself in the exercise below!

> ## Box plots
> Using the `gapminder_1997` data, use ggplot to create a box plot with continent on the x axis and life expectancy on the y axis. You can use the examples from earlier in the lesson as a template to remember how to pass ggplot data and map aesthetics and geometries onto the plot. If you're really stuck, feel free to use the internet as well!
>
> > ## Solution
> > ```{r GapBox}
> > ggplot(data = gapminder_1997) +
> >  aes(x = continent, y = lifeExp) +
> >  geom_boxplot()
> > ```
> {: .solution}
{: .challenge}

This type of visualization makes it easy to compare the range and spread of values across groups. The "middle" 50% of the data is located inside the box and outliers that are far away from the central mass of the data are drawn as points.

> ## Bonus Exercise: Other discrete geoms
> Take a look a the ggplot [cheat sheet](https://ggplot2.tidyverse.org/). Find all the geoms listed under "Discrete X, Continuous Y". Try replacing `geom_boxplot` with one of these other functions.
>
> > ## Example solution
> > ```{r GapViol}
> > ggplot(data = gapminder_1997) +
> >   aes(x = continent, y = lifeExp) +
> >   geom_violin()
> > ```
> {: .solution}
{: .challenge}

## Layers
_[Back to top](#contents)_

So far we've only been adding one geom to each plot, but each plot object can actually contain multiple layers and each layer has it's own geom. Let's start with a basic violin plot:

```{r GapViolin}
ggplot(data = gapminder_1997) +
  aes(x = continent, y = lifeExp) +
  geom_violin()
```

Violin plots are similar to box plots, but they show the range and spread of values with curves rather than boxes (wider curves = more observations) and they do not include outliers. Also note you need a minimum number of points so they can be drawn - because Oceania only has two values, it doesn't get a curve. We can include the Oceania data by adding a layer of points on top that will show us the "raw" data:

```{r GapViolinPoints}
ggplot(data = gapminder_1997) +
  aes(x = continent, y = lifeExp) +
  geom_violin() +
  geom_point()
```

OK, we've drawn the points but most of them stack up on top of each other. One way to make it easier to see all the data is to "jitter" the points, or move them around randomly so they don't stack up on top of each other. To do this, we use `geom_jitter` rather than `geom_point`

```{r GapViolinJitter}
ggplot(data = gapminder_1997) +
  aes(x = continent, y = lifeExp) +
  geom_violin() +
  geom_jitter()
```

Be aware that these movements are random so your plot will look a bit different each time you run it!

Now let's try switching the order of `geom_violin` and `geom_jitter`. What happens? Why?

```{r GapViolinJitterLayers}
ggplot(data = gapminder_1997) +
  aes(x = continent, y = lifeExp) +
  geom_jitter() +
  geom_violin()
```

Since we plot the `geom_jitter` layer first, the violin plot layer is placed on top of the `geom_jitter` layer, so we cannot see most of the points.

Note that each layer can have it's own set of aesthetic mappings. So far we've been using `aes()` outside of the other functions. When we do this, we are setting the "default" aesthetic mappings for the plot. We could do the same thing by passing the values to the `ggplot()` function call as is sometimes more common:

```{r GapViolinJitter2}
ggplot(data = gapminder_1997, mapping = aes(x = continent, y = lifeExp)) +
  geom_violin() +
  geom_jitter()
```

However, we can also use aesthetic values for only one layer of our plot. To do that, you can place an additional `aes()` inside of that layer. For example, what if we want to change the size for the points so they are scaled by population, but we don't want to change the violin plot? We can do:

```{r GapViolinJitterAes}
ggplot(data = gapminder_1997) +
  aes(x = continent, y = lifeExp) +
  geom_violin() +
  geom_jitter(aes(size = pop))
```

Both `geom_violin` and `geom_jitter` will inherit the default values of `aes(continent, lifeExp)` but only `geom_jitter` will also use `aes(size = pop)`.

> ## Functions within functions
>
> In the two examples above, we placed the `aes()` function inside another function - see how in the line of code `geom_jitter(aes(size = pop))`, `aes()` is nested **inside** `geom_jitter()`? When this happens, R evaluates the inner function first, then passes the output of that function as an argument to the outer function.
>
> Take a look at this simpler example. Suppose we have:
>
> ```{r, eval = FALSE}
> sum(2, max(6,8))
> ```
> First R calculates the maximum of the numbers 6 and 8 and returns the value 8. It passes the output 8 into the sum function and evaluates:
> ```{r}
> sum(2, 8)
> ```
>
{: .solution}


## Color vs. Fill 
_[Back to top](#contents)_

Let's say we want to spice up our plot a bit by adding some color. Maybe we want our violin color to a fancy color like "pink" We can do this by explicitly setting the color aesthetic inside the `geom_violin` function. Note that because we are assigning a color directly and not using any values from our data to do so, we do not need to use the `aes()` mapping function. Let's try it out:

```{r GapViolinColor}
ggplot(data = gapminder_1997) +
  aes(x = continent, y = lifeExp) +
  geom_violin(color="pink")
```

Well, that didn't get all that colorful. That's because objects like these violins have two different parts that have a color: the shape outline, and the inner part of the shape. For geoms that have an inner part, you change the fill color with `fill=` rather than `color=`, so let's try that instead

```{r GapViolinFill}
ggplot(data = gapminder_1997) +
  aes(x = continent, y = lifeExp) +
  geom_violin(fill="pink")
```

That's some plot now isn't it! Compare this to what you see when you map the fill property to your data rather than setting a specific value.

```{r GapViolinFillMap}
ggplot(data = gapminder_1997) +
  aes(x = continent, y = lifeExp) +
  geom_violin(aes(fill=continent))
```

So "pink" maybe wasn't the prettiest color. R knows lots of color names. You can see the full list if you run `colors()` in the console. Since there are so many, you can randomly choose 10 if you run `sample(colors(), size = 10)`.

> ## choosing a color
>  Use `sample(colors(), size = 10)` a few times until you get an interesting sounding color name and swap that out for "pink" in the violin plot example.
>
{: .challenge}


> ## Bonus Exercise: Transparency
> Another aesthetic that can be changed is how transparent our colors/fills are. The `alpha` parameter decides how transparent to make the colors. By default, `alpha = 1`, and our colors are completely opaque. Decreasing `alpha` increases the transparency of our colors/fills. Try changing the transparency of our violin plot. (**Hint:** Should alpha be inside or outside `aes()`?)
> > ## Solution
> > ```{r GapViolinFillSoln}
> > ggplot(data = gapminder_1997) +
> >   aes(x = continent, y = lifeExp) +
> >   geom_violin(fill="darkblue", alpha = 0.5)
> > ```
> {: .solution}
{: .challenge}

> ## Changing colors
> What happens if you run:
> ```{r GapViolinAesFillMap}
>  ggplot(data = gapminder_1997) +
>  aes(x = continent, y = lifeExp) +
>  geom_violin(aes(fill = "springgreen"))
> ```
> Why doesn't this work? How can you fix it? Where does that color come from?
>
> > ## Solution
> > In this example, you placed the fill inside the `aes()` function. Because you are using an aesthetic mapping, the "scale" for the fill will assign colors to values - in this case, you only have one value: the word "springgreen." Instead, try `geom_violin(fill = "springgreen")`.
> {: .solution}
{: .challenge}

## Univariate Plots
_[Back to top](#contents)_

We jumped right into make plots with multiple columns. But what if we wanted to take a look at just one column? In that case, we only need to specify a mapping for `x` and choose an appropriate geom. Let's start with a [histogram](https://www.thoughtco.com/what-is-a-histogram-3126359) to see the range and spread of the life expectancy values

```{r GapLifeHist}
ggplot(gapminder_1997) +
  aes(x = lifeExp) +
  geom_histogram()
```

You should not only see the plot in the plot window, but also a message telling you to choose a better bin value. Histograms can look very different depending on the number of bars you decide to draw. The default is 30. Let's try setting a different value by explicitly passing a `bin=` argument to the `geom_histogram` later.

```{r GapLifeHistBins}
ggplot(gapminder_1997) +
  aes(x = lifeExp) +
  geom_histogram(bins=20)
```

Try different values like 5 or 50 to see how the plot changes.

> ## Bonus Exercise: One variable plots
> Rather than a histogram, choose one of the other geometries listed under "One Variable" plots on the ggplot [cheat sheet](https://ggplot2.tidyverse.org/). Note that we used `lifeExp` here which has continuous values. If you want to try the discrete options, try mapping `continent` to x instead.
>
> > ## Example solution
> > ```{r GapLifeDens1}
> > ggplot(gapminder_1997) +
> >   aes(x = lifeExp) +
> >   geom_density()
> > ```
> {: .solution}
{: .challenge}


## Plot Themes
_[Back to top](#contents)_

Our plots are looking pretty nice, but what's with that grey background? While you can change various elements of a `ggplot` object manually (background color, grid lines, etc.) the `ggplot` package also has a bunch of nice built-in themes to change the look of your graph. For example, let's try adding `theme_classic()` to our histogram:

```{r GapLifeHistBinsClassicTheme}
ggplot(gapminder_1997) +
  aes(x = lifeExp) +
  geom_histogram(bins = 20) +
  theme_classic()
```

Try out a few other themes, to see which you like: `theme_bw()`, `theme_linedraw()`, `theme_minimal()`.

> ## Rotating x axis labels
> Often, you'll want to change something about the theme that you don't know how to do off the top of your head. When this happens, you can do an Internet search to help find what you're looking for. To practice this, search the Internet to figure out how to rotate the x axis labels 90 degrees. Then try it out using the histogram plot we made above. 
>
> > ## Solution
> > ```{r GapLifeDens2}
> > ggplot(gapminder_1997) +
> >   aes(x = lifeExp) +
> >   geom_histogram(bins = 20) + 
> >   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
> > ```
> {: .solution}
{: .challenge}

## Facets
_[Back to top](#contents)_

If you have a lot of different columns to try to plot or have distinguishable subgroups in your data, a powerful plotting technique called faceting might come in handy. When you facet your plot, you basically make a bunch of smaller plots and combine them together into a single image. Luckily, `ggplot` makes this very easy. Let's start with a simplified version of our first plot

```{r GapNoFacet}
ggplot(gapminder_1997) +
  aes(x = gdpPercap, y = lifeExp) +
  geom_point()
```

The first time we made this plot, we colored the points differently for each of the continents. This time let's actually draw a separate box for each continent. We can do this with `facet_wrap()`

```{r GapFacetWrap}
ggplot(gapminder_1997) +
  aes(x = gdpPercap, y = lifeExp) +
  geom_point() +
  facet_wrap(vars(continent))
```
Note that `facet_wrap` requires this extra helper function called `vars()` in order to pass in the column names. It's a lot like the `aes()` function, but it doesn't require an aesthetic name. We can see in this output that we get a separate box with a label for each continent so that only the points for that continent are in that box.

The other faceting function ggplot provides is `facet_grid()`. The main difference is that `facet_grid()` will make sure all of your smaller boxes share a common axis. In this example, we will stack all the boxes on top of each other into rows so that their x axes all line up.
```{r GapFacetGrid}
ggplot(gapminder_1997) +
  aes(x = gdpPercap, y = lifeExp) +
  geom_point() +
  facet_grid(rows = vars(continent))
```

Unlike the `facet_wrap` output where each box got its own x and y axis, with `facet_grid()`, there is only one x axis along the bottom.

## Saving plots
_[Back to top](#contents)_

We've made a bunch of plots today, but we never talked about how to share them with your friends who aren't running R! It's wise to keep all the code you used to draw the plot, but sometimes you need to make a PNG or PDF version of the plot so you can share it with your PI or post it to your Instagram story.

One that's easy if you are working in RStudio interactively is to use "Export" menu on the **Plots** tab. Clicking that button gives you three options "Save as Image", "Save as PDF", and "Copy To Clipboard". These options will bring up a window that will let you resize and name the plot however you like.

A better option to make your code to be more reproducible is to use the `ggsave()` function. When you call this function, it will write the last plot printed to a file in your local directory. It will determine the file type based on the name you provide. So if you call `ggsave("plot.png")` you'll get a PNG file or if you call `ggsave("plot.pdf")` you'll get a PDF file. By default the size will match the size of the **Plots** tab. To change that you can also supply `width=` and `height=` arguments. By default these values are interpreted as inches. So if you want a wide 4x6 image you could do something like:

```{r ggsave, eval=FALSE}
ggsave("figures/awesome_plot.jpg", width=6, height=4)
```

> ## Saving a plot
>
> Try rerunning one of your plots and then saving it using `ggsave()`. Find and open the plot to see if it worked!
>
> > ## Example solution
> > ```{r savingPlotExercise}
> > ggplot(gapminder_1997) +
> >   aes(x = lifeExp) +
> >   geom_histogram(bins = 20)+
> >   theme_classic()
> >
> > ggsave("awesome_histogram.jpg", width=6, height=4)
> > ```
> >
> > Check your current working directory to find the plot!
> {: .solution}
{: .challenge}

You also might want to just temporarily save a plot while you're using R, so that you can come back to it later. Luckily, a plot is just an object, like any other object we've been working with! Let's try storing our violin plot from earlier in an object called `violin_plot`:

```{r storeGapViolinFillMap}
violin_plot <- ggplot(data = gapminder_1997) +
                  aes(x = continent, y = lifeExp) +
                  geom_violin(aes(fill=continent))
```

Now if we want to see our plot again, we can just run:

```{r outputViolinPlot}
violin_plot
```

We can also add changes to the plot. Let's say we want our violin plot to have the black-and-white theme:

```{r violinPlotBWTheme}
violin_plot + theme_bw()
```

Watch out! Adding the theme does not change the `violin_plot` object! If we want to change the object, we need to store our changes:

```{r violinPlotBWThemeUpdated}
violin_plot <- violin_plot + theme_bw()
```

We can also save any plot object we have named, even if they were not the plot that we ran most recently. We just have to tell `ggsave()` which plot we want to save:

```{r ggsaveObject, eval=FALSE}
ggsave("figures/awesome_violin_plot.jpg", plot = violin_plot, width=6, height=4)
```

> ## Bonus Exercise: Create and save a plot
> Now try it yourself! Create your own plot using `ggplot()`, store it in an object named `my_plot`, and save the plot using `ggsave()`.
>
> > ## Example solution
> > ```{r createPlotSave}
> > my_plot <- ggplot(data = gapminder_1997)+
> >   aes(x = continent, y = gdpPercap)+
> >   geom_boxplot(fill = "orange")+
> >   theme_bw()+
> >   labs(x = "Continent", y = "GDP Per Capita")
> >
> > ggsave("my_awesome_plot.jpg", plot = my_plot, width=6, height=4)
> > ```
> {: .solution}
{: .challenge}


# Applying it to your own data
_[Back to top](#contents)_

Now that we've learned how impactful effective data visualization can be, and how to create informative visuals in R, it's time for you to start thinking about what you want to do with your own data!

Pair up with another learner and discuss discuss your data and what type of exploratory data analysis you would like to perform.

Questions to conisder:

1. What information do you have in your data set?
1. Are there specific questions are you interested in investigating with the data you have?
1. What visuals can you create to explore your data? Draw some out on paper! 
1. Is your data in a format that can easily be read into R? How can you improve the formatting of the contents of the file? 

# Glossary of terms
_[Back to top](#contents)_

- Aesthetic: a visual property of the objects (geoms) drawn in your plot (like x position, y position, color, size, etc)
- Aesthetic mapping (aes): This is how we connect a visual property of the plot to a column of our data
- Comments: lines of text in our code after a `#` that are ignored (not evaluated) by R
- Geometry (geom): this describes the things that are actually drawn on the plot (like points or lines)
- Facets: Dividing your data into non-overlapping groups and making a small plot for each subgroup
- Layer: Each ggplot is made up of one or more layers. Each layer contains one geometry and may also contain custom aesthetic mappings and private data
- Factor: a way of storing data to let R know the values are discrete so they get special treatment



