---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 04-r-data-cleaning-merging.md in _episodes_rmd/
title: "R for Data Cleaning and Merging"
source: Rmd
teaching: 75
exercises: 15
questions:
- "How can I combine two datasets from different sources?"
- "How can data tidying facilitate answering analysis questions?"
objectives:
- "To become familiar with more functions of the `dplyr` and `tidyr` packages."
- "To be able to use `dplyr` and `tidyr` to prepare data for analysis."
- "To be able to combine two different data sources using joins."
keypoints:
- "Assessing data source and structure is an important first step in analysis."
- "Data analysis in R facilitates reproducible research."
- "Preparing data for analysis can take significant effort and planning."
---



### Contents

1.  [Cleaning up data](#cleaning-up-data)
1.  [Joining data frames](#joining-data-frames)
1.  [Analyzing combined data](#analyzing-combined-data)

# Cleaning up data

[*Back to top*](#contents)

Researchers are often pulling data from several sources, and the process of making data compatible with one another and prepared for analysis can be a large undertaking. Luckily, there are many functions that allow us to do this in R. We've been working with the gapminder dataset, which contains population and GDP data by year. In this section, we practice cleaning and preparing a second dataset containing CO2 emissions data by country and year, sourced from [the UN](https://data.un.org/_Docs/SYB/CSV/SYB63_310_202009_Carbon%20Dioxide%20Emission%20Estimates.csv).

It's always good to go into data cleaning with a clear goal in mind. Here, we'd like to prepare the CO2 UN data to be compatible with our gapminder data so we can directly compare GDP to CO2 emissions. To make this work, we'd like a data frame that contains a column with the country name, and columns for different ways of measuring CO2 emissions. We will also want the data to be collected as close to 2007 as possible (the last year we have data for in gapminder). Let's start with reading the data in using `read_csv()`


~~~
read_csv("data/co2-un-data.csv")
~~~
{: .language-r}



~~~
Error in read_csv("data/co2-un-data.csv"): could not find function "read_csv"
~~~
{: .error}

The output gives us a warning about missing column names being filled in with things like 'X3', 'X4', etc. Looking at the table that is outputted by `read_csv()` we can see that there appear to be two rows at the top of the file that contain information about the data in the table. The first is a header that tells us the table number and its name. Ideally, we'd skip that. We can do this using the `skip=` argument in read_csv by giving it a number of lines to skip.


~~~
read_csv("data/co2-un-data.csv", skip=1)
~~~
{: .language-r}



~~~
Error in read_csv("data/co2-un-data.csv", skip = 1): could not find function "read_csv"
~~~
{: .error}

Now we get a similar Warning message as before, but the outputted table looks better.

> ## Warnings and Errors
> It's important to differentiate between Warnings and Errors in R. A warning tells us, "you might want to know about this issue, but R still did what you asked". An error tells us, "there's something wrong with your code or your data and R didn't do what you asked". You need to fix any errors that arise. Warnings, are probably best to resolve or at least understand why they are coming up.
{.callout}

We can resolve this warning by telling `read_csv()` what the column names should be with the `col_names()` argument where we give it the column names we want within the c() function separated by commas. If we do this, then we need to set skip to 2 to also skip the column headings. Let's also save this dataframe to `co2_emissions_dirty` so that we don't have to read it in every time we want to clean it even more.


~~~
co2_emissions_dirty <- read_csv("data/co2-un-data.csv", skip=2,
         col_names=c("region", "country", "year", "series", "value", "footnotes", "source"))
~~~
{: .language-r}



~~~
Error in read_csv("data/co2-un-data.csv", skip = 2, col_names = c("region", : could not find function "read_csv"
~~~
{: .error}



~~~
co2_emissions_dirty
~~~
{: .language-r}



~~~
Error in eval(expr, envir, enclos): object 'co2_emissions_dirty' not found
~~~
{: .error}

> ## Bonus: Another way to deal with this error
> 
> There are often multiple ways to clean data. Here we  read in the table, get the warning and then fix the column names using the rename function.
> 
> 
> ~~~
> read_csv("data/co2-un-data.csv", skip=1) %>%
>   rename(country=X2)
> ~~~
> {: .language-r}
> 
> 
> 
> ~~~
> Error in read_csv("data/co2-un-data.csv", skip = 1) %>% rename(country = X2): could not find function "%>%"
> ~~~
> {: .error}
>
> Many data analysts prefer to have their column headings and variable names be in all lower case. We can use a variation of `rename()`, which is `rename_all()` that allows us to set all of the column headings to lower case by giving it the name of the tolower function, which makes everything lowercase.
> 
> 
> ~~~
> read_csv("data/co2-un-data.csv", skip=1) %>%
>  rename_all(tolower)
> ~~~
> {: .language-r}
> 
> 
> 
> ~~~
> Error in read_csv("data/co2-un-data.csv", skip = 1) %>% rename_all(tolower): could not find function "%>%"
> ~~~
> {: .error}
{: .solution}

We previously saw how we can subset columns from a data frame using the select function. There are a lot of columns with extraneous information in this dataset, let's subset out the columns we are interested in. 

> ## Reviewing selecting columns
> Select the country, year, series, and value columns from our dataset. 
> 
> > ## Solution: 
> > 
> > ~~~
> > co2_emissions_dirty %>%
> >   select(country, year, series, value)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in co2_emissions_dirty %>% select(country, year, series, value): could not find function "%>%"
> > ~~~
> > {: .error}
> {: .solution}
{: .challenge}

The series column has two methods of quantifying CO2 emissions - "Emissions (thousand metric tons of carbon dioxide)" and "Emissions per capita (metric tons of carbon dioxide)". Those are long titles that we'd like to shorten to make them easier to work with. We can shorten them to "total_emissions" and "per_capita_emissions" using the recode function. We need to do this within the mutate function where we will mutate the series column. The syntax in the recode function is to tell recode which column we want to recode and then what the old value (e.g. "Emissions (thousand metric tons of carbon dioxide)") should equal after recoding (e.g. "total").


~~~
co2_emissions_dirty %>% 
  select(country, year, series, value) %>%
  mutate(series = recode(series, "Emissions (thousand metric tons of carbon dioxide)" = "total_emissions",
                         "Emissions per capita (metric tons of carbon dioxide)" = "per_capita_emissions"))
~~~
{: .language-r}



~~~
Error in co2_emissions_dirty %>% select(country, year, series, value) %>% : could not find function "%>%"
~~~
{: .error}

Recall that we'd like to have separate columns for the two ways that we CO2 emissions data. To achieve this, we'll use the pivot_wider function that we saw previously. The columns we want to spread out are series (i.e. names_from) and value (i.e. values_from).


~~~
co2_emissions_dirty %>%
  select(country, year, series, value) %>%
  mutate(series = recode(series, "Emissions (thousand metric tons of carbon dioxide)" = "total_emission",
                         "Emissions per capita (metric tons of carbon dioxide)" = "per_capita_emission")) %>%
  pivot_wider(names_from=series, values_from=value)
~~~
{: .language-r}



~~~
Error in co2_emissions_dirty %>% select(country, year, series, value) %>% : could not find function "%>%"
~~~
{: .error}

Excellent! The last step before we can join this data frame is to get the most data that is for the year closest to 2007 so we can make a more direct comparison to the most recent data we have from gapminder. For the sake of time, we'll just tell you that we want data from 2005. 

> ## Bonus: How did we determine that 2005 is the closest year to 2007? 
> 
> We want to make sure we pick a year that is close to 2005, but also a year that has a decent amount of data to work with. One useful tool is the `count()` function, which will tell us how many times a value is repeated in a column of a data frame. Let's use this function on the year column to see which years we have data for and to tell us whether we have a good number of countries represented in that year.
> 
> 
> ~~~
> co2_emissions_dirty %>%
>  select(country, year, series, value) %>%
>  mutate(series = recode(series, "Emissions (thousand metric tons of carbon dioxide)" = "total",
>                         "Emissions per capita (metric tons of carbon dioxide)" = "per_capita")) %>%
>   pivot_wider(names_from=series, values_from=value) %>%
>  count(year)
> ~~~
> {: .language-r}
> 
> 
> 
> ~~~
> Error in co2_emissions_dirty %>% select(country, year, series, value) %>% : could not find function "%>%"
> ~~~
> {: .error}
> 
> It looks like we have data for 140 countries in 2005 and 2010. We chose 2005 because it is closer to 2007. 
{: .solution}


> ## Filtering rows and removing columns
> Filter out data from 2005 and then drop the year column. (Since we will have only data from one year, it is now irrelevant.)
> 
> > ## Solution: 
> > 
> > ~~~
> > co2_emissions_dirty %>%
> >  select(country, year, series, value) %>%
> >  mutate(series = recode(series, "Emissions (thousand metric tons of carbon dioxide)" = "total",
> >                         "Emissions per capita (metric tons of carbon dioxide)" = "per_capita")) %>%
> >  pivot_wider(names_from=series, values_from=value) %>%
> >  filter(year==2005) %>%
> >  select(-year)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in co2_emissions_dirty %>% select(country, year, series, value) %>% : could not find function "%>%"
> > ~~~
> > {: .error}
> {: .solution}
{: .challenge}


Finally, let's go ahead and assign the output of this code chunk, which is the cleaned dataframe, to a variable name:


~~~
co2_emissions <- co2_emissions_dirty %>%
  select(country, year, series, value) %>%
  mutate(series = recode(series, "Emissions (thousand metric tons of carbon dioxide)" = "total_emission",
                         "Emissions per capita (metric tons of carbon dioxide)" = "per_capita_emission")) %>%
  pivot_wider(names_from=series, values_from=value) %>%
  filter(year==2005) %>%
  select(-year)
~~~
{: .language-r}



~~~
Error in co2_emissions_dirty %>% select(country, year, series, value) %>% : could not find function "%>%"
~~~
{: .error}

> **Looking at your data:** You can get a look at your data-cleaning hard work by navigating to the **Environment** tab in RStudio and clicking the table icon next to the variable name. Notice when we do this, RStudio automatically runs the `View()` command. We've made a lot of progress!
{.callout}

# Joining data frames

[*Back to top*](#contents)


Now we're ready to join our CO2 emissions data to the gapminder data. Previously we saw that we could read in and filter the gapminder data like this to get the data from the Americas for 2007 so we can create a new dataframe with our filtered data:


~~~
gapminder_data_2007 <- read_csv("data/gapminder_data.csv") %>%
  filter(year == 2007 & continent == "Americas") %>%
  select(-year, -continent)
~~~
{: .language-r}



~~~
Error in read_csv("data/gapminder_data.csv") %>% filter(year == 2007 & : could not find function "%>%"
~~~
{: .error}

Look at the data in `co2_emissions` and `gapminder_data_2007`. If you had to merge these two data frames together, which column would you use to merge them together? If you said "country" - good job!

We'll call country our "key". Now, when we join them together, can you think of any problems we might run into when we merge things? We might not have CO2 emissions data for all of the countries in the gapminder dataset and vice versa. Also, a country might be represented in both data frames but not by the same name in both places. As an example, write down the name of the country that the University of Michigan is in - we'll come back to your answer shortly!

The dplyr package has a number of tools for joining data frames together depending on what we want to do with the rows of the data of countries that are not represented in both data frames. Here we'll be using `inner_join()` and `anti_join()`. 

In an "inner join", the new data frame only has those rows where the same key is found in both data frames. This is a very commonly used join.

![]({{ page.root }}/fig/r-data-analysis/join-inner.png)

> ## Bonus: Other dplyr join functions 
>
> Outer joins and can be performed using `left_join()`, `right_join()`, and `full_join()`. In a "left join", if the key is present in the left hand data frame, it will appear in the output, even if it is not found in the the right hand data frame. For a right join, the opposite is true. For a full join, all possible keys are included in the output data frame.
> 
> ![]({{ page.root }}/fig/r-data-analysis/join-outer.png)
{: .solution}

If you don't already have it read in, read in the gapminder data:


~~~
gapminder_data <- read_csv('data/gapminder_data.csv')
~~~
{: .language-r}



~~~
Error in read_csv("data/gapminder_data.csv"): could not find function "read_csv"
~~~
{: .error}


Let's give the `inner_join()` function a try.

~~~
inner_join(gapminder_data, co2_emissions)
~~~
{: .language-r}



~~~
Error in inner_join(gapminder_data, co2_emissions): could not find function "inner_join"
~~~
{: .error}

Do you see that we now have data from both data frames joined together in the same data frame? One thing to note about the output is that `inner_join()` tells us that that it joined by "country". We can make this explicit using the "by" argument in the join functions


~~~
inner_join(gapminder_data, co2_emissions, by="country")
~~~
{: .language-r}



~~~
Error in inner_join(gapminder_data, co2_emissions, by = "country"): could not find function "inner_join"
~~~
{: .error}

One thing to notice is that gapminder data had 25 rows, but the output of our join only had 21. Let's investigate. It appears that there must have been countries in the gapminder data that did not appear in our co2_emissions data frame. 

Let's use `anti_join()` for this - this will show us the data for the keys on the left that are missing from the data frame on the right. 


~~~
anti_join(gapminder_data, co2_emissions, by="country")
~~~
{: .language-r}



~~~
Error in anti_join(gapminder_data, co2_emissions, by = "country"): could not find function "anti_join"
~~~
{: .error}
We can see that the co2_emissions data were missing for Bolivia, Puerto Rico, United States, and Venezuela. 

If we look at the co2_emissions data with `View()`, we will see that Bolivia, United States, and Venezuela are called different things in the co2_emissions data frame. They're called "Bolivia (Plurin. State of)", "United States of America", and "Venezuela (Boliv. Rep. of)". Puerto Rico isn't a country; it's part of the United States. Using `mutate()` and `recode()`, we can re-import the co2_emissions data so that the country names for Bolivia, United States, and Venezuela, match those in the gapminder data.


~~~
co2_emissions <- read_csv("data/co2-un-data.csv", skip=2,
                          col_names=c("region", "country", "year",
                                      "series", "value", "footnotes", "source")) %>%
  select(country, year, series, value) %>%
  mutate(series = recode(series, "Emissions (thousand metric tons of carbon dioxide)" = "total",
                         "Emissions per capita (metric tons of carbon dioxide)" = "per_capita")) %>%
  pivot_wider(names_from=series, values_from=value) %>%
  filter(year==2005) %>%
  select(-year) %>%
  mutate(country=recode(country,
                        "Bolivia (Plurin. State of)" = "Bolivia",
                        "United States of America" = "United States",
                        "Venezuela (Boliv. Rep. of)" = "Venezuela")
  )
~~~
{: .language-r}



~~~
Error in read_csv("data/co2-un-data.csv", skip = 2, col_names = c("region", : could not find function "%>%"
~~~
{: .error}



~~~
anti_join(gapminder_data, co2_emissions, by="country")
~~~
{: .language-r}



~~~
Error in anti_join(gapminder_data, co2_emissions, by = "country"): could not find function "anti_join"
~~~
{: .error}

Now we see that our recode enabled the join for all countries in the gapminder, and we are left with Puerto Rico. In the next exercise, let's recode Puerto Rico as United States in the gapminder data and then use `group_by()` and `summarize()` to aggregate the data; we'll use the population data to weight the life expectancy and GDP values.


In the gapminder data, let's recode Puerto Rico as United States. 

~~~
gapminder_data <- read_csv("data/gapminder_data.csv") %>%
filter(year == 2007 & continent == "Americas") %>%
select(-year, -continent) %>%
mutate(country = recode(country, "Puerto Rico" = "United States")) 
~~~
{: .language-r}



~~~
Error in read_csv("data/gapminder_data.csv") %>% filter(year == 2007 & : could not find function "%>%"
~~~
{: .error}

Now we have to group Puerto Rico and the US together, aggregating and calculating the data for all of the other columns. This is a little tricky - we will need a weighted average of lifeExp and gdpPercap. You can do this using standard order of operations. 


~~~
gapminder_data <- read_csv("data/gapminder_data.csv") %>%
  filter(year == 2007 & continent == "Americas") %>%
  select(-year, -continent) %>%
  mutate(country = recode(country, "Puerto Rico" = "United States")) %>%
  group_by(country) %>%
  summarize(lifeExp = sum(lifeExp * pop)/sum(pop),
            gdpPercap = sum(gdpPercap * pop)/sum(pop),
            pop = sum(pop)
  )
~~~
{: .language-r}



~~~
Error in read_csv("data/gapminder_data.csv") %>% filter(year == 2007 & : could not find function "%>%"
~~~
{: .error}

Let's check to see if it worked! 

~~~
anti_join(gapminder_data, co2_emissions, by="country")
~~~
{: .language-r}



~~~
Error in anti_join(gapminder_data, co2_emissions, by = "country"): could not find function "anti_join"
~~~
{: .error}
Now our `anti_join()` returns an empty data frame, which tells us that we have reconciled all of the keys from the gapminder data with the data in the co2_emissions data frame.

Finally, let's use the `inner_join()` to create a new data frame:


~~~
gapminder_co2 <- inner_join(gapminder_data, co2_emissions, by="country")
~~~
{: .language-r}



~~~
Error in inner_join(gapminder_data, co2_emissions, by = "country"): could not find function "inner_join"
~~~
{: .error}

One last thing! What if we're interested in distinguishing between countries in North America and South America? We want to create two groups - Canada, the United States, and Mexico in one and the other countries in another.  

We can create a grouping variable using `mutate()` combined with an `if_else()` function - a very useful pairing.  
 

~~~
gapminder_co2 %>%  
mutate(region = if_else(country == "Canada" | country == "United States" | country == "Mexico", "north", "south"))  
~~~
{: .language-r}



~~~
Error in gapminder_co2 %>% mutate(region = if_else(country == "Canada" | : could not find function "%>%"
~~~
{: .error}
Let's look at the output - see how the Canada, US, and Mexico rows are all labeled as "north" and everything else is labeled as "south"  

We have reached our data cleaning goals! One of the best aspects of doing all of these steps coded in R is that our efforts are reproducible, and the raw data is maintained. With good documentation of data cleaning and analysis steps, we could easily share our work with another researcher who would be able to repeat what we've done. However, it's also nice to have a saved `csv` copy of our clean data. That way we can access it later without needing to redo our data cleaning, and we can also share the cleaned data with collaborators. To save our dataframe, we'll use `write_csv()`. 


~~~
write_csv(gapminder_co2, "data/gapminder_co2.csv")
~~~
{: .language-r}



~~~
Error in write_csv(gapminder_co2, "data/gapminder_co2.csv"): could not find function "write_csv"
~~~
{: .error}

Great - Now we can move on to the analysis! 

# Analyzing combined data

[*Back to top*](#contents)

For our analysis, we have two questions we'd like to answer. First, is there a relationship between the GDP of a country and the amount of CO2 emitted (per capita)? Second, Canada, the United States, and Mexico account for nearly half of the population of the Americas. What percent of the total CO2 production do they account for?

To answer the first question, we'll plot the CO2 emitted (on a per capita basis) against the GDP (on a per capita basis) using a scatter plot:


~~~
ggplot(gapminder_co2, aes(x=gdpPercap, y=per_capita)) +
  geom_point() +
  labs(x="GDP (per capita)",
       y="CO2 emitted (per capita)",
       title="There is a strong association between a nation's GDP \nand the amount of CO2 it produces"
  )
~~~
{: .language-r}



~~~
Error in ggplot(gapminder_co2, aes(x = gdpPercap, y = per_capita)): could not find function "ggplot"
~~~
{: .error}

*Tip:* Notice we used the `\n` in our title to get a new line to prevent it from getting cut off.

To help clarify the association, we can add a fit line through the data using `geom_smooth()`


~~~
ggplot(gapminder_co2, aes(x=gdpPercap, y=per_capita)) +
  geom_point() +
  labs(x="GDP (per capita)",
       y="CO2 emitted (per capita)",
       title="There is a strong association between a nation's GDP \nand the amount of CO2 it produces"
  ) +
  geom_smooth()
~~~
{: .language-r}



~~~
Error in ggplot(gapminder_co2, aes(x = gdpPercap, y = per_capita)): could not find function "ggplot"
~~~
{: .error}

We can force the line to be straight using `method="lm"` as an argument to `geom_smooth`


~~~
ggplot(gapminder_co2, aes(x=gdpPercap, y=per_capita)) +
  geom_point() +
  labs(x="GDP (per capita)",
       y="CO2 emitted (per capita)",
       title="There is a strong association between a nation's GDP \nand the amount of CO2 it produces"
  ) +
  geom_smooth(method="lm")
~~~
{: .language-r}



~~~
Error in ggplot(gapminder_co2, aes(x = gdpPercap, y = per_capita)): could not find function "ggplot"
~~~
{: .error}

To answer our first question, as the title of our plot indicates there is indeed a strong association between a nation's GDP and the amount of CO2 it produces.

For the second question, we want to create two groups - Canada, the United States, and Mexico in one and the other countries in another.

We can create a grouping variable using `mutate()` combined with an `if_else()` function - a very useful pairing.


~~~
gapminder_co2 %>%
  mutate(region = if_else(country == "Canada" | country == "United States" | country == "Mexico", "north", "south"))
~~~
{: .language-r}



~~~
Error in gapminder_co2 %>% mutate(region = if_else(country == "Canada" | : could not find function "%>%"
~~~
{: .error}

Now we can use this column to repeat our `group_by()` and `summarize()` steps


~~~
gapminder_co2 %>%
  mutate(region = if_else(country == "Canada" |
                            country == "United States" |
                            country == "Mexico", "north", "south")) %>%
  group_by(region) %>%
  summarize(sumtotal = sum(total),
            sumpop = sum(pop))
~~~
{: .language-r}



~~~
Error in gapminder_co2 %>% mutate(region = if_else(country == "Canada" | : could not find function "%>%"
~~~
{: .error}

The `if_else()` statement reads like, "if country equals "Canada" OR `|` "United states" OR "Mexico", the new variable region should be "north", else "south"". It's worth exploring logical operators for "or" `|`, "and" `&&`, and "not" `!`, which opens up a great deal of possibilities for writing code to do what you want.

We see that although Canada, the United States, and Mexico account for close to half the population of the Americas, they account for 88% of the CO2 emitted. We just did this math quickly by plugging the numbers from our table into the console to get the percentages. Can we make that a little more reproducible by calculating percentages for population (pop) and total emissions (total) into our data before summarizing?


# Bonus 

## Bonus exercise

> ## Calculating percent
>
> What percentage of the population and CO2 emissions in the Americas does the United States make up? What percentage of the population and CO2 emission does North America make up? 
>
> > ## Solution
> >
> > Create a new variable using `mutate()` that calculates percentages for the pop and total variables.
> >
> > 
> > ~~~
> > gapminder_co2 %>%
> >   mutate(region = if_else(country == "Canada" | country == "United States" | country == "Mexico", "north", "south")) %>%
> >   mutate(totalPercent = total/sum(total)*100,
> >          popPercent = pop/sum(pop)*100)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in gapminder_co2 %>% mutate(region = if_else(country == "Canada" | : could not find function "%>%"
> > ~~~
> > {: .error}
> >
> > This table shows that the United states makes up 33% of the population of the Americas, but accounts for 77% of total emissions. Now let's take a look at population and emission for the two different continents: 
> >
> > 
> > ~~~
> > gapminder_co2 %>%
> >   mutate(region = if_else(country == "Canada" | country == "United States" | country == "Mexico", "north", "south")) %>%
> >   mutate(totalPercent = total/sum(total)*100,
> >          popPercent = pop/sum(pop)*100) %>%
> >   group_by(region) %>%
> >   summarize(sumTotalPercent = sum(totalPercent),
> >             sumPopPercent = sum(popPercent))
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error in gapminder_co2 %>% mutate(region = if_else(country == "Canada" | : could not find function "%>%"
> > ~~~
> > {: .error}
> > 
> {: .solution}
{: .challenge}

